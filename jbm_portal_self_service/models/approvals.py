# -*- coding: utf-8 -*-from odoo import models, fields, api, _from odoo.exceptions import ValidationErrorimport jsonclass ApprovalCategory(models.Model):    _inherit = 'approval.category'    approval_type = fields.Selection(selection_add=[        ('certification', 'Certification'),        ('clearance', 'Clearances Request'),        ('resignation', 'Resignation'),        ('attendance', 'Attendance'),        ('change_data', 'Change data'),        ('job_card', 'Job Card'),        ('work_start', 'Work Start'),        ('performance_grievance', 'Performance evaluation grievance'),        ('access', 'Access'),        ('it', 'Device, technical defect support, other'),        ('permit_over_time', 'Permit Work')    ])    select_type = fields.Selection([        ('it_equipment', 'IT Equipment'),        ('training_course', 'Training Course Request'),        ('insurance_request', 'Insurance Request'), ])    previous_request_count = fields.Integer("Number of requests",                                            compute="_compute_previous_request_count")    def _compute_previous_request_count(self):        domain = []        requests_data = self.env['approval.request'].read_group(domain, ['category_id'], ['category_id'])        requests_mapped_data = dict((data['category_id'][0], data['category_id_count']) for data in requests_data)        for category in self:            category.previous_request_count = requests_mapped_data.get(category.id, 0)class ApprovalRequest(models.Model):    _inherit = 'approval.request'    product_category_id = fields.Many2one(comodel_name="product.category", string="Type", required=False, )    select_type = fields.Selection(related="category_id.select_type")    # emp_children_ids = fields.One2many('hr.emp.child', 'approval_request_id')    children_id = fields.Many2many('hr.emp.child')    date_from = fields.Datetime()    date_to = fields.Datetime()    partner_id = fields.Many2one('res.partner', domain=[('is_employee', '=', True)])    in_out_document_device = fields.Selection([        ('allowed', 'Allowed'),        ('not_allowed', 'Not Allowed'),    ])    determined_allowed = fields.Text()    @api.constrains("date_from")    def check_date_from(self):        for rec in self:            if rec.date_from:                day = str(rec.date_from.weekday())                hour_from = rec.date_from.strftime("%H")                min_from = rec.date_from.strftime("%M")                total_time = float(hour_from) + float(min_from) / 100                emp = rec.env['hr.employee'].search([('id', '=', rec.request_employee_id.id)])                hour_to = emp.resource_calendar_id.attendance_ids.filtered(lambda s: s.dayofweek == day).filtered(lambda s: s.day_period == 'afternoon').hour_to                if total_time < hour_to:                    raise ValidationError("time period must be outside the employee's normal scheduled working hours.")    @api.constrains("date_to")    def check_date(self):        for rec in self:            if rec.date_from and rec.date_to and rec.date_to < rec.date_from:                raise ValidationError("time of 'Date to' must be higher than time of 'Date from'")    def unlink(self):        if self.env.user.has_group('base_portal_user.group_user_portal') and \                any(state == 'approved' for state in self.mapped('request_status')):            if self.env.context.get('lang') == 'ar_001':                raise ValidationError(_("لا يمكنك مسح اى طلب تم الموافقة عليه ...."))            else:                raise ValidationError(_("You can\'t delete approved request ...."))        return super(ApprovalRequest, self).unlink()    @api.onchange('product_category_id')    def _onchange_product_category_id(self):        self.write({'product_line_ids': [(6, 0, [])]})    def write(self, vals):        if vals and 'date_confirmed' not in vals and self.request_status != 'new' and 'can_see_eligible' not in vals:            if self.env.user.has_group('jbm_portal_self_service.group_self_service_user') or self.env.user.has_group('jbm_portal_self_service.group_self_service_manager'):                if self.env.context.get('lang') == 'ar_001':                    raise ValidationError('لا يمكن تحديث البيانات بعد إرسال الطلب.')                else:                    raise ValidationError('You are not allowed to edit a request after submission.')        return super(ApprovalRequest, self).write(vals)    def action_print(self):        return self.env.ref('jbm_portal_self_service.approval_permit_over_time_request'). \            report_action(self)class ApprovalProductLine(models.Model):    _inherit = 'approval.product.line'    product_category_id = fields.Many2one(comodel_name="product.category",                                          related='approval_request_id.product_category_id')    # product_id_domain = fields.Char(    #     compute="_compute_product_id_domain",    #     readonly=True,    #     store=False,    # )    #    # @api.depends('product_category_id', 'product_id')    # def _compute_product_id_domain(self):    #     print("hello from domain 2")    #     print("category_id", self.product_category_id)    #     for rec in self:    #         rec.product_id_domain = json.dumps(    #             [('category2_id', '=', self.product_category_id.id)]    #         )    #         print(rec.product_id_domain)    # @api.onchange('product_category_id')    # def _onchange_approval_request_id(self):    #     if self.product_category_id:    #         return {    #             'domain': {    #                 'product_id': [('categ_id', '!=', self.product_category_id.id)]    #             }    #         }    #     else:    #         return {'domain': {'product_id': []}}